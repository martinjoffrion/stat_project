---
title: "stats_905"
author: "MJ_AK"
date: "2024-02-07"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Statistiques  Modèles linéaires

# M2 SIGMA  UE 905

## F. Laroche

## 2023-2024

## Question 1

```{r}
# imports
library(car)

setwd("C:/ENSAT/stat_project")
data <- read.csv("dataProjet_2024.csv", header = T, sep = ",")

# filtrer dataset
data_quercus <- data[data$recherche_esp_lb_nom_plantae == "Quercus L., 1753",]

# modèle ANOVA
modAnovRegQuad2_Querc_BC <- lm(I(log10(DBH))~alti+I(alti^2)+releve,data=data_quercus) 
modAnov_resStand <- rstandard(modAnovRegQuad2_Querc_BC)

### Hypothèse 1 : loi gaussienne des erreurs

par(mfrow=c(2,2))
bks <- seq(-6,6,0.1)
qqPlot(modAnov_resStand,distribution="norm",mean=0,sd=1,line="none")
hist(modAnov_resStand, probability=T, breaks=bks)

lines(bks,dnorm(bks,0,1),col="blue")

### Hypothèse 2 : indépendance des erreurs

vecIndObs <- as.numeric(rownames(modAnovRegQuad2_Querc_BC$model))
boxplot(modAnov_resStand~data_quercus$releve[vecIndObs],xlab="", 
        ylab="Résidu standardisé",las=2,range=0)
abline(h=0,lty="dashed")

### Hypothèse 3 : homoscédasticité des erreurs

#SL-plot
plot(modAnovRegQuad2_Querc_BC,which=3,pch=3, add.smooth = FALSE) #Base du SL-plot pré-programmée dans R
abline(h=0.8,col=4,lwd=2) #Ligne horizontale attendue
lo <- loess(sqrt(abs(modAnov_resStand))~modAnovRegQuad2_Querc_BC$fitted.values) #Moyenne glissante des points
vFit <- sort(unique(modAnovRegQuad2_Querc_BC$fitted.values))
predLo <- predict(lo,vFit,se=TRUE)
lines(predLo$fit~vFit,col=2,lwd=2)
#Enveloppe de confiance autour de cette moyenne glissante :
nFit <- length(vFit); ICBonf <- qnorm(1-0.05/2/nFit)
lines(predLo$fit+ICBonf*predLo$se.fit~sort(
    unique(modAnovRegQuad2_Querc_BC$fitted.values)
  ),col=2,lwd=2,lty="dashed")
lines(predLo$fit-ICBonf*predLo$se.fit~sort(
    unique(modAnovRegQuad2_Querc_BC$fitted.values)
  ),col=2,lwd=2,lty="dashed")

```

## Question 2

```{r}

modAnova <- lm(DBH~0+releve+recherche_esp_lb_nom_plantae,data=data)
modAnov_resStand <- rstandard(modAnova)

### Hypothèse 1 : loi gaussienne des erreurs

par(mfrow=c(2,2))
bks <- seq(-7,7,0.1)
qqPlot(modAnov_resStand,distribution="norm",mean=0,sd=1,line="none")
hist(modAnov_resStand, probability=T, breaks=bks)
lines(bks,dnorm(bks,0,1),col="blue")

### Hypothèse 2 : indépendance des erreurs

vecIndObs <- as.numeric(rownames(modAnova$model))
boxplot(modAnov_resStand~data_quercus$releve[vecIndObs],xlab="", 
        ylab="Résidu standardisé",las=2,range=0)
abline(h=0,lty="dashed")

### Hypothèse 3 : homoscédasticité des erreurs

#SL-plot
plot(modAnova,which=3,pch=3, add.smooth = FALSE) #Base du SL-plot pré-programmée dans R
abline(h=0.8,col=4,lwd=2) #Ligne horizontale attendue
lo <- loess(sqrt(abs(modAnov_resStand))~modAnova$fitted.values) #Moyenne glissante des points
vFit <- sort(unique(modAnova$fitted.values))
predLo <- predict(lo,vFit,se=TRUE)
lines(predLo$fit~vFit,col=2,lwd=2)
#Enveloppe de confiance autour de cette moyenne glissante :
nFit <- length(vFit); ICBonf <- qnorm(1-0.05/2/nFit)
lines(predLo$fit+ICBonf*predLo$se.fit~sort(
    unique(modAnova$fitted.values)
  ),col=2,lwd=2,lty="dashed")
lines(predLo$fit-ICBonf*predLo$se.fit~sort(
    unique(modAnova$fitted.values)
  ),col=2,lwd=2,lty="dashed")


### Analyse des sorties
  # estimation des intervalles de confiance
summary(modAnova)$coefficients
tabConfInt <- confint(modAnova,level=0.95)
par(mfrow=c(1,2))

x <- barplot(summary(modAnova)$coefficients[,1],las=2)
arrows(x0 = x, y0= tabConfInt[,1],
  y1=tabConfInt[,2], code=3,angle=90,
  length=0.05)

  # test de significativité selon une sous-population de référence

#Définition d'une sous-population de référence, ici BLO_11 
data$releve <- relevel(as.factor(data$releve),ref="BLO_1")

#Reformulation du modèle ANOVA :
modAnovaDif <- lm(DBH~releve+recherche_esp_lb_nom_plantae,data=data)
summary(modAnovaDif)$coefficients

summary(modAnova)$coefficients
summary(modAnovaDif)$coefficients
tabConfInt <- confint(modAnovaDif,level=0.95)


## R²
x <- boxplot(DBH~releve,data=data,range=0,las=2,xlab="",cex.axis=0.5)
vCoef <- modAnova$coefficients[
    match(x$names,gsub("releve","",names(modAnova$coefficients)))]
points(1:length(vCoef),rep(mean(data$DBH,na.rm=TRUE),length(vCoef)),pch=21,bg=4)
points(1:length(vCoef),
  modAnova$coefficients[
    match(x$names,gsub("releve","",names(modAnova$coefficients)))],
  pch=21,bg=2)
```

## Question 3
```{r}
 
data_quercus$triangle[data_quercus$releve == 'BLO_12'|
                 data_quercus$releve == 'BLO_13'|
                 data_quercus$releve == 'BLO_17'] <- 'TR_1'

data_quercus$triangle[data_quercus$releve == 'BLO_1'|
                 data_quercus$releve == 'BLO_4'|
                 data_quercus$releve == 'BLO_9'] <- 'TR_2'

data_quercus$triangle[data_quercus$releve == 'BLO_21'|
                 data_quercus$releve == 'BLO_24'|
                 data_quercus$releve == 'BLO_27'] <- 'TR_3'

### Plot
plot(lati~long, data=data_quercus,xlab="Longitude WGS84",ylab="Latitude WGS84",pch=3)
triangle <-  unique(data_quercus$triangle)
col_pal <- c('red','green','blue')
for (i in 1:length(triangle))
  {
  data_temp <- data_quercus[data_quercus$triangle == triangle[i],]

  coorPla <- sapply(unique(data_temp$releve),function(idPla){
   vIndPla <- which(data_temp$releve==idPla)
   latiPla <- mean(data_temp$lati[vIndPla],na.rm=TRUE)
   longPla <- mean(data_temp$long[vIndPla],na.rm=TRUE)
   return(c(longPla,latiPla))
  })
  polygon(coorPla[1,],coorPla[2,],col = col_pal[i] )
}

coorPla <- sapply(unique(data_quercus$releve),function(idPla){
 vIndPla <- which(data_quercus$releve==idPla)
 latiPla <- mean(data_quercus$lati[vIndPla],na.rm=TRUE)
 longPla <- mean(data_quercus$long[vIndPla],na.rm=TRUE)
 return(c(longPla,latiPla))
})
text(coorPla[1,],coorPla[2,],colnames(coorPla),col=4,cex=0.5,font=2)


### Define Triangle model
modAnovaTriangle <- lm(DBH~0+triangle,data=data_quercus)
modAnov_resStand <- rstandard(modAnovaTriangle)

### Hypothèse 1 : loi gaussienne des erreurs

par(mfrow=c(2,2))
bks <- seq(-3,8,0.1)
qqPlot(modAnov_resStand,distribution="norm",mean=0,sd=1,line="none")
hist(modAnov_resStand, probability=T, breaks=bks)
lines(bks,dnorm(bks,0,1),col="blue")

### Hypothèse 2 : indépendance des erreurs

vecIndObs <- as.numeric(rownames(modAnova$model))
boxplot(modAnov_resStand~data_quercus$releve[vecIndObs],xlab="", 
        ylab="Résidu standardisé",las=2,range=0)
abline(h=0,lty="dashed")

### Hypothèse 3 : homoscédasticité des erreurs

#SL-plot
plot(modAnovaTriangle,which=3,pch=3, add.smooth = FALSE) #Base du SL-plot pré-programmée dans R
abline(h=0.8,col=4,lwd=2) #Ligne horizontale attendue
lo <- loess(sqrt(abs(modAnov_resStand))~modAnovaTriangle$fitted.values) #Moyenne glissante des points
vFit <- sort(unique(modAnovaTriangle$fitted.values))
predLo <- predict(lo,vFit,se=TRUE)
lines(predLo$fit~vFit,col=2,lwd=2)
#Enveloppe de confiance autour de cette moyenne glissante :
nFit <- length(vFit); ICBonf <- qnorm(1-0.05/2/nFit)
lines(predLo$fit+ICBonf*predLo$se.fit~sort(
    unique(modAnovaTriangle$fitted.values)
  ),col=2,lwd=2,lty="dashed")
lines(predLo$fit-ICBonf*predLo$se.fit~sort(
    unique(modAnovaTriangle$fitted.values)
  ),col=2,lwd=2,lty="dashed")

### F test : comparaison avec test sans regroupemment des sous pop

modAnovaReleve <- lm(DBH~0+releve,data=data_quercus)
anova(modAnovaTriangle, modAnovaReleve)

#F=239.87 avec p<<0.05 donc triqngle diminue valeur R21, car modèle simple = triangle et modèle complexe = modele releve

```
## Question 4
```{r}


```

